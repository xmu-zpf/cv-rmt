///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 22.11.2.0
// Non-ASCII strings in this file are encoded in local-8-bit encoding (cp936).
// Ensure that the interface encoding is set to locale encoding by calling
// SetHcppInterfaceStringEncodingIsUtf8(false) at the beginning of the program.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#    include <HALCON/HpThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#    include <HALCONxl/HpThread.h>
#  endif
#  include <stdio.h>
#  include <CoreFoundation/CFRunLoop.h>
#endif



using namespace HalconCpp;


#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_OriginImg, ho_GrayImage, ho_binImg;
  HObject  ho_Contours, ho_ContEllipse;

  // Local control variables
  HTuple  hv_SlctdImgPath, hv_t1, hv_Row, hv_Column;
  HTuple  hv_Phi, hv_Radius1, hv_Radius2, hv_StartPhi, hv_EndPhi;
  HTuple  hv_PointOrder, hv_t2, hv_elapsed;

  // dev_open_file_dialog(...); only in hdevelop
  ReadImage(&ho_OriginImg, hv_SlctdImgPath);

  Rgb1ToGray(ho_OriginImg, &ho_GrayImage);

  Threshold(ho_GrayImage, &ho_binImg, 128, 255);

  GenContourRegionXld(ho_binImg, &ho_Contours, "border");

  CountSeconds(&hv_t1);
  FitEllipseContourXld(ho_Contours, "fitzgibbon", -1, 2, 0, 200, 3, 2, &hv_Row, &hv_Column, 
      &hv_Phi, &hv_Radius1, &hv_Radius2, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  CountSeconds(&hv_t2);
  hv_elapsed = hv_t2-hv_t1;

  if (HDevWindowStack::IsOpen())
    SetColor(HDevWindowStack::GetActive(),"green");

  GenEllipseContourXld(&ho_ContEllipse, hv_Row, hv_Column, hv_Phi, hv_Radius1, hv_Radius2, 
      hv_StartPhi, hv_EndPhi, hv_PointOrder, 1.5);
}


#ifndef NO_EXPORT_APP_MAIN

#ifdef __APPLE__
// On OS X systems, we must have a CFRunLoop running on the main thread in
// order for the HALCON graphics operators to work correctly, and run the
// action function in a separate thread. A CFRunLoopTimer is used to make sure
// the action function is not called before the CFRunLoop is running.
// Note that starting with macOS 10.12, the run loop may be stopped when a
// window is closed, so we need to put the call to CFRunLoopRun() into a loop
// of its own.
static HMutex*     sStartMutex;
static H_pthread_t sActionThread;
static bool        sTerminate = false;

static void timer_callback(CFRunLoopTimerRef timer, void *info)
{
  sStartMutex->UnlockMutex();
}

static Herror apple_action(void **parameters)
{
  // Wait until the timer has fired to start processing.
  sStartMutex->LockMutex();
  sStartMutex->UnlockMutex();

  try
  {
    action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
  }

  // Tell the main thread to terminate itself.
  sStartMutex->LockMutex();
  sTerminate = true;
  sStartMutex->UnlockMutex();
  CFRunLoopStop(CFRunLoopGetMain());
  return H_MSG_OK;
}

static int apple_main(int argc, char *argv[])
{
  Herror                error;
  CFRunLoopTimerRef     Timer;
  CFRunLoopTimerContext TimerContext = { 0, 0, 0, 0, 0 };

  sStartMutex = new HMutex("type","sleep");
  sStartMutex->LockMutex();

  error = HpThreadHandleAlloc(&sActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleAlloc failed: %d\n", error);
    exit(1);
  }

  error = HpThreadCreate(sActionThread,0,apple_action);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadCreate failed: %d\n", error);
    exit(1);
  }

  Timer = CFRunLoopTimerCreate(kCFAllocatorDefault,
                               CFAbsoluteTimeGetCurrent(),0,0,0,
                               timer_callback,&TimerContext);
  if (!Timer)
  {
    fprintf(stderr,"CFRunLoopTimerCreate failed\n");
    exit(1);
  }
  CFRunLoopAddTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);

  for (;;)
  {
    bool terminate;

    CFRunLoopRun();

    sStartMutex->LockMutex();
    terminate = sTerminate;
    sStartMutex->UnlockMutex();

    if (terminate)
      break;
  }

  CFRunLoopRemoveTimer(CFRunLoopGetCurrent(),Timer,kCFRunLoopCommonModes);
  CFRelease(Timer);

  error = HpThreadHandleFree(sActionThread);
  if (H_MSG_OK != error)
  {
    fprintf(stderr,"HpThreadHandleFree failed: %d\n", error);
    exit(1);
  }

  delete sStartMutex;
  return 0;
}
#endif
//
//int main(int argc, char *argv[])
//{
//  int ret = 0;
//
//  try
//  {
//#if defined(_WIN32)
//    SetSystem("use_window_thread", "true");
//#endif
//
//    // file was stored with local-8-bit encoding
//    //   -> set the interface encoding accordingly
//    SetHcppInterfaceStringEncodingIsUtf8(false);
//
//    // Default settings used in HDevelop (can be omitted)
//    SetSystem("width", 512);
//    SetSystem("height", 512);
//
//#ifndef __APPLE__
//    action();
//#else
//    ret = apple_main(argc,argv);
//#endif
//  }
//  catch (HException &exception)
//  {
//    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
//            exception.ProcName().TextA(),
//            exception.ErrorMessage().TextA());
//    ret = 1;
//  }
//  return ret;
//}

#endif


#endif


